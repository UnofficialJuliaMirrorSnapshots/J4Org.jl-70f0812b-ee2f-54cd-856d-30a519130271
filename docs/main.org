#+SETUPFILE: ./Setup/setupFile.org
#+AUTHOR: Vincent Picaud
#+PROPERTY: header-args:julia :session *JuliaDoc_session* :exports code :eval no-export
#+HTML_HEAD_EXTRA: <style type="text/css"> blockquote {background:#EEEEEE; padding: 3px 13px}    </style>
#+HTML_HEAD_EXTRA: <style type="text/css"> pre {background:#EEEEEE; padding: 3px 13px}    </style>
#+TITLE: Package Documentation

#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

#+BEGIN_SRC julia :results output none :eval no-export :exports none
using Revise
using J4Org
initialize_boxing_module(boxingModule="J4OrgBoxing",usedModules=["J4Org"],force=true)
cd(expanduser("~/GitHub/J4Org.jl/docs/"))
#+END_SRC

# Also use Foo as example 
#+BEGIN_SRC julia :results output none :eval no-export :exports none
push!(LOAD_PATH,pwd()*"/minimal_example/")
initialize_boxing_module(usedModules=["Foo"],force=true)
#+END_SRC

* Introduction

J4Org.jl is a Julia package that allows Julia doc generation into an
Org-Mode document. The goal is to be able to code and document Julia
packages without leaving Emacs and to reduce as much as possible the
burden of documentation. This package depends on [[https://github.com/KristofferC/Tokenize.jl/][Tokenize.jl]], to
tokenize Julia code.

** Minimal requirements 

You need [[https://orgmode.org/][Org-Mode]] plus [[https://github.com/gjkerns/ob-julia/blob/master/ob-julia-doc.org][ob-julia.el]], which has [[http://stat.ethz.ch/ESS/index.php?Section=download][ESS]] as dependence, to be
installed.

** Getting started with a minimal example

The following is a minimal example you can reproduce to have a taste
of what this package do.

*** Emacs configuration

You first need a minimal =init.el= file to configure Emacs.

#+BEGIN_SRC emacs-lisp :eval never :tangle yes :tangle minimal_example/init.el
(package-initialize)

(require 'ess-site)
;; if required
;; (setq  inferior-julia-program-name "/path/to/julia-release-basic")

(require 'org)
;; *replace me* with your own ob-julia.el file location 
(add-to-list 'load-path "~/GitLab/WorkingWithOrgMode/EmacsFiles")
;; babel configuration
(setq org-confirm-babel-evaluate nil)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((julia . t)))
#+END_SRC

#+RESULTS:

*** A documented Julia =Foo= module
    :PROPERTIES:
    :ID:       2ae4bb8f-17f2-4cb7-9fba-eff22bea6a92
    :END:

Then you need a documented module:

#+BEGIN_SRC julia :eval never :tangle yes :tangle minimal_example/Foo.jl
module Foo

export Point, foo
    
import Base: norm

#+Point L:Point_struct
# This is my Point structure
#
# *Example:*
#
# Creates a point $p$ of coordinates $(x=1,y=2)$.
#
# #+BEGIN_SRC julia :eval never :exports code
# p=Point(1,2)
# #+END_SRC
#
# You can add any valid Org mode directive. If you want to use
# in-documentation link, use [[norm_link_example][]]
#
struct Point
    x::Float64
    y::Float64
end

#+Point
# Creates Point at origin $(0,0)$ 
Point() = Point(0,0)

#+Enum
# An enum
@enum Alpha A=1 B C # just for example

#+Point,Method L:norm_link_example
# A simple function that computes $\sqrt{x^2+y^2}$
#
# *Example:*
#!p=Point(1.0,2.0);
#!norm(p) 
#
# See: [[Point_struct][]]
#
norm(p::Point)::Float64 = sqrt(p.x*p.x+p.y*p.y)

# +Method,Internal
# An internal function
#
# For symbol that are not exported, do not forget the "Foo." prefix:
# !p=Point(1.0,2.0)
# !Foo.foo(2.0,p)
foo(r::Float64,p::Point) = Point(r*p.x,r*p.y)

end 
#+END_SRC

I wanted to reduce the documentation process as much as possible. The
template is very simple. Before each item you want to document add
these comment lines:

#+BEGIN_SRC julia :eval never :exports code 
#+Tag1,Tag2,... L:an_extra_link_if_required 
#
# Here you can put any Org mode text, for instance $sin(x)$
#
#!sin(5) # julia code to be executed
#
# [[internal_link][]]
struct A_Documented_Struct 
...
end 
#+END_SRC

- *#+Tag1,Tag2,...* is mandatory, "#+" is followed by a list of
  tags. Later when you want to extract doc you can do filtering
  according these tags.

- *L:an_extra_link_if_required* is *not* mandatory. It defines a
  reference if you want to create doc links. The previous statement
  defines a link *target* named =an_extra_link_if_required=.

- *[[internal_link][]]* creates a link to a previously defined
  *L:internal_link*.

- *!sin(5)* will execute Julia code and include the output in the
  doc. If you only want to include Julia code without executing it,
  simply use Org mode source block:
#+BEGIN_SRC julia :eval never :exports code 
# #+BEGIN_SRC julia :eval never :exports code
# sin(5)
# #+END_SRC
#+END_SRC

**** Support for "# +" and "# !" (since v0.2.0)

As you can see (foo() function comments), "# \plus", "#\plus" and "#
!", "#!" are synonyms.  The motivation is a better integration with
[[https://github.com/QBobWatson/poporg][poporg]] Emacs package.  With this Emacs package you can edit comment
under OrgMode mode without being bothered by the "#" characters.

*** Minimal OrgMode document

This is the =foo.org= file.

# I use bash instead of org, othewise PDF export is not working properly.
#+BEGIN_SRC org :eval never :tangle yes :tangle minimal_example/foo.org 
,#+PROPERTY: header-args:julia :session *my_session* :exports code :eval no-export
,#+OPTIONS: ^:{}
,#+TITLE: Getting Started with a minimal example

,#+BEGIN_SRC julia :results output none :eval no-export :exports none
push!(LOAD_PATH,pwd())
,#+END_SRC

,#+BEGIN_SRC julia :results output none :eval no-export :exports none
using J4Org 
initialize_boxing_module(usedModules=["Foo"]) 
documented_items=create_documented_item_array("Foo.jl")
,#+END_SRC

,* Example

Prints all documented items, except those tagged with "Internal" 
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
print_org_doc(documented_items,tag_to_ignore=["Internal"],header_level=0)
,#+END_SRC
#+END_SRC

#+RESULTS:


- *push!(LOAD_PATH,pwd())* tells Julia where it can find our local =Foo=
  module. This statement is only required if the documented module is
  in an unusual place.

- *using J4Org* uses this package

- *initialize_boxing_module(usedModules=["Foo"])* defines what are
  the modules to use when executing Julia code extracted from the doc
  (the "#!" statements). Here we are documenting the =Foo= module,
  hence we must use it. Note that you can also use any number of extra
  modules for instance with =["Foo", "ExtraModule", ...]=. See
  [[API_initialize_boxing_module][initialize_boxing_module(...)]] for further details.

- *create_documented_item_array("Foo.jl")* creates the list of
  documented items from file "Foo.jl". You can use a list of files and
  a directory, see [[API_create_documented_item_array_filename][create_documented_item_array(...)]] for further details.

- *print_org_doc(documented_items,tag_to_ignore=["Internal"],header_level=0)*
  prints all documented items, except those tagged with "Internal",
  see [[API_print_org_doc_API][print_org_doc(...)]] for further details

*** Generating the doc

To check that it works you can start a fresh emacs with

#+BEGIN_SRC bash :eval never
emacs -q --load init.el foo.org &
#+END_SRC

#+RESULTS:

then type:
- =C-c C-v b= + =RET= to execute all source code blocks
- =C-c C-e h o= to html-export the file 
- =C-c C-e l o= to pdf-export the file 

You should get this [[file:minimal_example/foo.html][minimal_example/foo.html]] file.

*** Improving exported document style

This was a minimal example, you can have a better look for the
exported documents by including css theme, etc. This is the approach
we used to generate *this* document (also see the [[file:main.pdf][main.pdf]] PDF file).
Another example is [[https://vincent-picaud.github.io/DirectConvolution.jl/docs.html][DirectConvolution.jl documentation]]. 

* More examples 

We still use our [[id:2ae4bb8f-17f2-4cb7-9fba-eff22bea6a92][=Foo=]] module to provide more examples. The complete [[id:c9053a86-dea5-4bc2-a883-92a1bfde20ba][API]] is detailed after.

** =print_org_doc= options

The [[API_print_org_doc_API][print_org_doc(...)]] function has several options, let's see some usage examples

*** =header_level=

This integer can have these values:
- *-1*: do not print header nor index, see [[id:bda53362-32fb-4096-9c0a-32c0afb96b5f][header_level=-1]]
- *0*: print header beginning with "-", see [[id:842e5c47-62d1-44fc-8489-e105a45f5dd4][header_level=0]].
- *l>0* create subsection of level *l*, for instance *header_level=3*
  creates subsections beginning with *3* stars. See
  [[id:0f6a49dc-ee9f-4964-8801-8badfb67f735][header_level=5]]. *Caveat:* for *l>0* AFAIK there is a bug in OrgMode,
  because a residual *:RESULT:* is printed.

**** header_level=-1
     :PROPERTIES:
     :ID:       bda53362-32fb-4096-9c0a-32c0afb96b5f
     :END:

#+BEGIN_src julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results 
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=-1,with_body=true)
,#+END_SRC
#+END_SRC

This will generate (here =with_body=true= this mean that we also
extract code body).

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results 
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=-1,with_body=true)
#+END_SRC

#+RESULTS:
:RESULTS:

ERROR: AssertionError: Module BoxingModule does not exist, create a new one with initialize_boxing_module()
Stacktrace:
 [1] with_hash_evaluate(::String, ::String) at /home/picaud/GitHub/J4Org.jl/src/evaluate.jl:92
 [2] org_string_comment(::J4Org.Documented_Item, ::Array{J4Org.Documented_Item,1}, ::Array{J4Org.Documented_Item,1}, ::String, ::String) at /home/picaud/GitHub/J4Org.jl/src/org_string_comment.jl:34
 [3] #org_string_documented_item#32(::String, ::Bool, ::String, ::String, ::Int64, ::String, ::Bool, ::Function, ::J4Org.Documented_Item, ::Array{J4Org.Documented_Item,1}, ::Array{J4Org.Documented_Item,1}) at /home/picaud/GitHub/J4Org.jl/src/main.jl:107
 [4] #org_string_documented_item at ./none:0 [inlined]
 [5] #org_string_documented_item_array#39(::Int64, ::String, ::Bool, ::Bool, ::String, ::Bool, ::Function, ::Array{J4Org.Documented_Item,1}, ::getfield(J4Org, Symbol("#predicate#46")){String,String,String}) at /home/picaud/GitHub/J4Org.jl/src/main.jl:305
 [6] #org_string_documented_item_array at ./none:0 [inlined]
 [7] #org_string_documented_item_array#45 at /home/picaud/GitHub/J4Org.jl/src/main.jl:349 [inlined]
 [8] #org_string_documented_item_array at ./none:0 [inlined]
 [9] #print_org_doc#47 at /home/picaud/GitHub/J4Org.jl/src/main.jl:391 [inlined]
 [10] (::getfield(J4Org, Symbol("#kw##print_org_doc")))(::NamedTuple{(:tag, :header_level, :with_body),Tuple{String,Int64,Bool}}, ::typeof(print_org_doc), ::Array{J4Org.Documented_Item,1}) at ./none:0
 [11] top-level scope at none:0
:END:


**** header_level=0
     :PROPERTIES:
     :ID:       842e5c47-62d1-44fc-8489-e105a45f5dd4
     :END:

#+BEGIN_src julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=0)
,#+END_SRC
#+END_SRC

This will generate:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:
2.23606797749979


<<dBCvfWoi>> *Index:* *[f]* [[5c0v1kbs][foo]] *[n]* [[WebpFDJ0][norm]] 
- @@latex:\phantomsection@@ *=foo=*  <<5c0v1kbs>>
#+BEGIN_SRC julia :eval never :exports code
foo(r::Float64,p::Point)
#+END_SRC
#+BEGIN_QUOTE
An internal function

For symbol that are not exported, do not forget the "Foo." prefix:
#+BEGIN_SRC julia
p=Point(1.0,2.0)
Foo.foo(2.0,p)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia
Foo.Point(1.0, 2.0)
Foo.Point(2.0, 4.0)
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:minimal_example/Foo.jl::46][Foo.jl:46]], [[dBCvfWoi][back to index]]
- @@latex:\phantomsection@@ *=norm=*  <<WebpFDJ0>> <<UFoNykVZnorm_link_example>>
#+BEGIN_SRC julia :eval never :exports code
norm(p::Point)::Float64
#+END_SRC
#+BEGIN_QUOTE
A simple function that computes $\sqrt{x^2+y^2}$

*Example:*
#+BEGIN_SRC julia
p=Point(1.0,2.0);
norm(p) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia
2.23606797749979
#+END_SRC

#+RESULTS:
: 2.23606797749979

See: _struct Point_
#+END_QUOTE
[[file:minimal_example/Foo.jl::35][Foo.jl:35]], [[dBCvfWoi][back to index]]
:END:



**** header_level=5
     :PROPERTIES:
     :ID:       0f6a49dc-ee9f-4964-8801-8badfb67f735
     :END:

#+BEGIN_src julia :eval never :exports code 
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=5)
,#+END_SRC
#+END_SRC

This will generate:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=5)
#+END_SRC

#+RESULTS:
:RESULTS:

<<ixVQVKHc>> *Index:* *[f]* [[wGdX72MB][foo]] *[n]* [[okPNhSsO][norm]] 
***** *=foo=*  <<wGdX72MB>>
#+BEGIN_SRC julia :eval never :exports code
foo(r::Float64,p::Point)
#+END_SRC
#+BEGIN_QUOTE
An internal function

For symbol that are not exported, do not forget the "Foo." prefix:
#+BEGIN_SRC julia
p=Point(1.0,2.0)
Foo.foo(2.0,p)
#+END_SRC
#+BEGIN_SRC julia
Foo.Point(1.0, 2.0)
Foo.Point(2.0, 4.0)
#+END_SRC
#+END_QUOTE
[[file:minimal_example/Foo.jl::46][Foo.jl:46]], [[ixVQVKHc][back to index]]
***** *=norm=*  <<okPNhSsO>> <<LO8vGNMEnorm_link_example>>
#+BEGIN_SRC julia :eval never :exports code
norm(p::Point)::Float64
#+END_SRC
#+BEGIN_QUOTE
A simple function that computes $\sqrt{x^2+y^2}$

*Example:*
#+BEGIN_SRC julia
p=Point(1.0,2.0);
norm(p) 
#+END_SRC
#+BEGIN_SRC julia
2.23606797749979
#+END_SRC

See: _struct Point_
#+END_QUOTE
[[file:minimal_example/Foo.jl::35][Foo.jl:35]], [[ixVQVKHc][back to index]]
:END:

*** =tag=, =tag_to_ignore=, =identifier=
    :PROPERTIES:
    :ID:       0e085bd4-7c99-44d6-8220-3e397fff8458
    :END:

These options allow to select items to include:

- =tag= a string or an array of strings, collects all items with at least one tag in this =tag= option.
- =tag_to_ignore= a string or an array of strings, ignore all items with at least one tag in this =tag_to_ignore= option.
- =identifier= a string that stands for the structure, abstract type or function name. Collects all items with this =identifier= name.

For instance we can print =norm= identifier, restricted to =Point= tag, as follows:

#+BEGIN_src julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,identifier="norm", tag="Point",header_level=-1)
,#+END_SRC
#+END_SRC

This will generate:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,identifier="norm", tag="Point",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:

 @@latex:\phantomsection@@  <<e6h2ajhanorm_link_example>>
#+BEGIN_SRC julia :eval never :exports code
norm(p::Point)::Float64
#+END_SRC
#+BEGIN_QUOTE
A simple function that computes $\sqrt{x^2+y^2}$

*Example:*
#+BEGIN_SRC julia
p=Point(1.0,2.0);
norm(p) 
#+END_SRC
#+BEGIN_SRC julia
2.23606797749979
#+END_SRC

See: _struct Point_
#+END_QUOTE
[[file:minimal_example/Foo.jl::35][Foo.jl:35]]
:END:

*** =complete_link=

If you look back at [[id:0e085bd4-7c99-44d6-8220-3e397fff8458][=tag=, =tag_to_ignore=, =identifier=]] you can see,
at the end of the =norm= function documentation, that the
_Point_struct_ link is not active. The reason is that the =Point=
structure is not present. The =complete_link= option, if set to =true=
will try to fix all dangling links by including all the required
documented items. For instance, with:

#+BEGIN_src julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,identifier="norm", tag="Point",header_level=-1,
              complete_link=true)
,#+END_SRC
#+END_SRC

This will generate:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,identifier="norm", tag="Point",header_level=-1,
              complete_link=true)
#+END_SRC

#+RESULTS:
:RESULTS:

 @@latex:\phantomsection@@  <<MVpMsBmwPoint_struct>>
#+BEGIN_SRC julia :eval never :exports code
struct Point
#+END_SRC
#+BEGIN_QUOTE
This is my Point structure

*Example:*

Creates a point $p$ of coordinates $(x=1,y=2)$.

#+BEGIN_SRC julia :eval never :exports code
p=Point(1,2)
#+END_SRC

You can add any valid Org mode directive. If you want to use
in-documentation link, use [[MVpMsBmwnorm_link_example][norm(...)]]
#+END_QUOTE
[[file:minimal_example/Foo.jl::8][Foo.jl:8]]
 @@latex:\phantomsection@@  <<MVpMsBmwnorm_link_example>>
#+BEGIN_SRC julia :eval never :exports code
norm(p::Point)::Float64
#+END_SRC
#+BEGIN_QUOTE
A simple function that computes $\sqrt{x^2+y^2}$

*Example:*
#+BEGIN_SRC julia
p=Point(1.0,2.0);
norm(p) 
#+END_SRC
#+BEGIN_SRC julia
2.23606797749979
#+END_SRC

See: [[MVpMsBmwPoint_struct][struct Point]]
#+END_QUOTE
[[file:minimal_example/Foo.jl::35][Foo.jl:35]]
:END:

you see that the =Point= structure is included to make the
_struct_Point_ link active.

*** =link_prefix=

You can create link from your OrgMode document to Julia documented
items that have defined a "L:link_target". However like these items
can be extracted at several places in your OrgMode document you need
to define a prefix to avoid multiple targets with the same name.

For instance, chose a prefix, here "my_prefix" and use:
#+BEGIN_SRC julia :results none :eval never :exports code
print_org_doc(documented_items,...,link_prefix="my_prefix_")
#+END_SRC
then you can create a regular OrgMode link to this item using
​ *[​[my_prefix_link_target][some_text]]*.


*** =case_sensitive=

When set to true, generates an index as follows:
#+BEGIN_EXAMPLE
[A] ..., [B] ...,[a] ..., [b] ...,
#+END_EXAMPLE

When set to false, do not split upper/lower cases and group all A,a;B,b together:
#+BEGIN_EXAMPLE
[A] ..., [B] ...
#+END_EXAMPLE

*** =boxingModule=

Comments starting with "#!" are executed in a boxed environment
#+BEGIN_SRC julia :eval never 
module MyBoxing
using RequiredPackage_1,RequiredPackage_2,...
end 
#+END_SRC

#+BEGIN_SRC julia :eval never 
using MyBoxing

# execute "#!" statements here
#+END_SRC

This boxing is defined by the [[API_initialize_boxing_module][initialize_boxing_module(...)]] function:

#+BEGIN_SRC julia :eval never
initialize_boxing_module(boxingModule="MyBoxing",
                         usedModules=["RequiredPackage_1","RequiredPackage_2",...])
#+END_SRC

This =boxingModule= option allows you to chose your boxing environment:
#+BEGIN_SRC julia :eval never
print_org_doc(documented_items,boxingModule="MyBoxing",...)
#+END_SRC

** Error reporting
Error reporting is performed as OrgMode comment. For instance if you execute:
#+BEGIN_src julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results 
documented_items=create_documented_item_array("minimal_example/Foo.jl");
print_org_doc(documented_items,tag="Method",header_level=-1)
,#+END_SRC
#+END_SRC


you will get:
#+BEGIN_src julia :eval never :exports code
#+RESULTS:
:RESULTS:
# =WARNING:= Link target ("Point_struct", "") not found
...
:END:
#+END_SRC 
** Compatibility with docstring / documenter.jl
You can still use something like:
#+BEGIN_SRC julia :eval never :exports code
"""
    foo()

foo function ...
"""
#+Tags...
# foo function ...
foo() = ...
#+END_SRC

* API
  :PROPERTIES:
  :ID:       c9053a86-dea5-4bc2-a883-92a1bfde20ba
  :END:

The API is simple, with very few functions:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("../src/");
print_org_doc(documented_items,boxingModule="J4OrgBoxing",tag=["API","Internal"],header_level=0,link_prefix="API_",with_body=true)
#+END_SRC

#+RESULTS:
:RESULTS:

<<kgn9knpD>> *Index:* *[D]* [[qm975XlT][Documented_Item]] *[c]* [[ZizOkgIU][create_documented_item_array]], [[b5m6Kbh3][create_documented_item_array_dir]], [[MA6vbIHd][create_group]] *[f]* [[1YuNv0Hp][find_closing_X_helper]], [[h8VHlw3U][find_closing_block]] *[g]* [[iK4GjSxa][group_by_identifier_case_nonsensitive]], [[T9plU2ml][group_by_identifier_case_sensitive]] *[i]* [[lyFPWy8S][initialize_boxing_module]], [[Igmna4FW][is_endmarker]], [[cnlfU4gA][is_enum]], [[B3AHGHUx][is_opening_parenthesis]], [[ovJKVcOA][is_structure]], [[MrpF1KWz][is_whitespace_n]] *[o]* [[LtzKMe0E][org_string_code]], [[UCIW5kc5][org_string_code_with_body]] *[p]* [[6NnAKWM4][print_org_doc]] *[r]* [[HsvMoBaE][raw_string_with_body]] *[s]* [[tCR0D5WJ][skip_abstract_block]], [[PX7r6tvj][skip_comma_separated_identifiers]], [[YI07DWf2][skip_comment]], [[tOSOPVhb][skip_declaration_block]], [[20w33ocb][skip_enum_block]], [[mSsOaF7i][skip_function_call_block]], [[SaViG9fx][skip_identifier]], [[Fgozo6uY][skip_issubtype_block]], [[QpWx2mHu][skip_line]], [[yuPCfAhE][skip_macro_block]], [[37LOskpd][skip_struct_block]], [[bSaTXGqn][skip_uninformative]], [[FTJIISZE][skip_variable_block]], [[vQ8mjYCX][skip_where_block]], [[AGMSIZGx][skip_whitespace]], [[7P1f9wMv][skip_whitespace_strict]] *[t]* [[tmrp9U7X][tokenized]] 
- @@latex:\phantomsection@@ *=Documented_Item=*  <<qm975XlT>> <<API_Documented_Item>>
#+BEGIN_SRC julia :eval never :exports code
struct Documented_Item
#+END_SRC
#+BEGIN_QUOTE
A *central* structure containing documented item
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
struct Documented_Item
    _filename::String
    _extracted_tag::Extract_Tag_Result
    _doc::Union{Nothing,
                Extracted_Comment}
    _code::Extracted_Item_Base
end
#+END_SRC
[[file:../src/documented_item.jl::1][documented_item.jl:1]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=create_documented_item_array=*  <<ZizOkgIU>> <<API_create_documented_item_array_filename>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename::String)::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads a Julia code file and returns an array of documented items.
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename::String)::Array{Documented_Item,1}

    if VERSION < v"0.7"
        code = readstring(filename)
    else
        code = read(filename,String)
    end
    
    tok=tokenized(code)

    n=length(tok)
    idx=1
    toReturn=Array{Documented_Item,1}(0)
    
    while idx<=n
        extracted_tag = find_tag(tok,idx)

        # no more tag?
        # 
        if extracted_tag==nothing
            break
        end 

        try
            di=create_documented_item(extracted_tag,filename=filename)
            push!(toReturn,di)
        catch msg
            warning_message("cannot interpret $(filename):$(line(extracted_tag)) $(msg)")
        end

        # important to rescan after tag (and not after code):
        # tag1
        # struct foo
        #   tag2 <- catch me!
        #   constructor
        # end 
        idx=skip(extracted_tag)
    end
#+END_SRC
[[file:../src/documented_item.jl::97][documented_item.jl:97]], [[kgn9knpD][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename_list::Array{String,1})::Array{Documented_Item,1}
#+END_SRC
#+BEGIN_QUOTE
Reads an array of Julia code files and returns an array of
documented items.

*Usage example:* 
#+BEGIN_SRC julia
create_documented_item_array(["file1","file2",...])
#+END_SRC

*Note:* instead of a list of files you can also specify a directory,
see [[API_create_documented_item_array_dir][create_documented_item_array_dir(...)]]
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array(filename_list::Array{String,1})::Array{Documented_Item,1}
    docItem_array = Array{Documented_Item,1}()
    
    for file in filename_list
        docItem_array = vcat(docItem_array,create_documented_item_array(file))
    end 

    return docItem_array
end
#+END_SRC
[[file:../src/documented_item.jl::142][documented_item.jl:142]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=create_documented_item_array_dir=*  <<b5m6Kbh3>> <<API_create_documented_item_array_dir>>
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array_dir(dirname::AbstractString)
#+END_SRC
#+BEGIN_QUOTE
Reads all *.jl files in a directory and returns an array of
documented items.
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function create_documented_item_array_dir(dirname::AbstractString)
    # expanded_dirname=expanduser(dirname)
    # @assert isdir(expanded_dirname)
    # # tips from https://stackoverflow.com/questions/20484581/search-for-files-in-a-folder
    # files=filter(x->contains(x,r".jl$"), readdir(expanded_dirname))
    # map!(x->expanded_dirname*x,files,files)

    file_names=scan_directory_return_file_names(dirname)
    files=filter_julia_source_code_file_names(file_names)
    return create_documented_item_array(files)
end
#+END_SRC
[[file:../src/documented_item.jl::189][documented_item.jl:189]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=create_group=*  <<MA6vbIHd>>
#+BEGIN_SRC julia :eval never :exports code
function create_group(array::Array{T,1},t::Function)::Array{UnitRange{Int},1} where {T}
#+END_SRC
#+BEGIN_QUOTE
Given a transformation t(x) creates groups (a vector of UnitRange) where
t(x_i), i in group_k is constant

*Caveat:* to make sense, the input array must be sorted.
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function create_group(array::Array{T,1},t::Function)::Array{UnitRange{Int},1} where {T}
    groups=Array{UnitRange{Int},1}(0)
    n = length(array)
    if length(array)==0
        return groups
    end 
    i,j=1,2
    current_identifier = t(array[1])
    while(j<=n)
        if current_identifier!=t(array[j])
            push!(groups,i:j-1)
            i=j
            current_identifier=t(array[j])
        end
        j=j+1
    end
#+END_SRC
[[file:../src/main.jl::124][main.jl:124]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=find_closing_X_helper=*  <<1YuNv0Hp>>
#+BEGIN_SRC julia :eval never :exports code
function find_closing_X_helper(tok::Tokenized,idx::Int,
                               is_opening_X::Function,
                               is_closing_X::Function,
                               count_opening::Int = 0)::Int
#+END_SRC
#+BEGIN_SRC julia :eval never :exports code
function find_closing_X_helper(tok::Tokenized,idx::Int,
                               is_opening_X::Function,
                               is_closing_X::Function,
                               count_opening::Int = 0)::Int

    # @assert is_opening_X(tok,idx)
    
    # count_opening = 0
    while idx<=length(tok)
        if is_opening_X(tok,idx)
            count_opening =  count_opening+1
	    idx=idx+1
            continue
        end

        if is_closing_X(tok,idx)
            count_opening = count_opening-1
            if count_opening == 0
                return idx
            end
        end
        idx=idx+1
    end
#+END_SRC
[[file:../src/tokenizer.jl::137][tokenizer.jl:137]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=find_closing_block=*  <<h8VHlw3U>>
#+BEGIN_SRC julia :eval never :exports code
function find_closing_block(tok::Tokenized,idx::Int,
                            count_opening::Int = 0)::Int
#+END_SRC
#+BEGIN_QUOTE
Find closing block (-> END)

This function does not impose that the idx position is an opening
block. If this is the case use the count_opening::Int = 0 default
value.

If you want to reach end of block starting from an already opened
one (for instance from the middle of a function body, use the
count_opening::Int = 1 value.
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function find_closing_block(tok::Tokenized,idx::Int,
                            count_opening::Int = 0)::Int
    return find_closing_X_helper(tok,idx,
                                 is_opening_block,
                                 is_closing_block,
                                 count_opening)
end
#+END_SRC
[[file:../src/tokenizer.jl::191][tokenizer.jl:191]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=group_by_identifier_case_nonsensitive=*  <<iK4GjSxa>>
#+BEGIN_SRC julia :eval never :exports code
function group_by_identifier_case_nonsensitive(di_array::Array{Documented_Item,1})::Array{UnitRange{Int},1}
#+END_SRC
#+BEGIN_QUOTE
Creates groups sharing the same identifier with correct lexical order 

This version is *case nonsensitive*
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function group_by_identifier_case_nonsensitive(di_array::Array{Documented_Item,1})::Array{UnitRange{Int},1}

    # Group without taking into account uppercase/lowercase
    #
    t(x)=uppercase(identifier(x))
    sort!(di_array, by = t)
    groups = create_group(di_array,t)
    
    # Sort taking account uppercase/lowercase for each group
    #
    for group_i in groups
        sort!(view(di_array,group_i), by = x -> identifier(x))
    end
    # Rebuild group taking account uppercase/lowercase
    #
    groups = create_group(di_array,x->identifier(x))
    
    return groups
end
#+END_SRC
[[file:../src/main.jl::150][main.jl:150]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=group_by_identifier_case_sensitive=*  <<T9plU2ml>>
#+BEGIN_SRC julia :eval never :exports code
function group_by_identifier_case_sensitive(di_array::Array{Documented_Item,1})::Array{UnitRange{Int},1}
#+END_SRC
#+BEGIN_QUOTE
Creates groups sharing the same identifier with correct lexical order 

This version is *case sensitive* (capitals are in front)
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function group_by_identifier_case_sensitive(di_array::Array{Documented_Item,1})::Array{UnitRange{Int},1}

    # Group without taking into account uppercase/lowercase
    #
    t(x)=identifier(x)
    sort!(di_array, by = t)
    groups = create_group(di_array,t)
    
    return groups
end
#+END_SRC
[[file:../src/main.jl::175][main.jl:175]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=initialize_boxing_module=*  <<lyFPWy8S>> <<API_initialize_boxing_module>>
#+BEGIN_SRC julia :eval never :exports code
function initialize_boxing_module(;
                                  boxingModule::String="BoxingModule",
                                  usedModules::Vector{String}=String[],
                                  force::Bool=false)::Nothing
#+END_SRC
#+BEGIN_QUOTE
Initialize a boxing module. This module is used to run Julia comment
code snippet (tagged by "#!" or by "# !")

*Example:*
#+BEGIN_SRC julia :eval never :exports code
initialize_boxing_module(boxingModule="MyBoxing",
                         usedModules=["RequiredPackage_1",
                                      "RequiredPackage_2",...])
#+END_SRC

creates

#+BEGIN_SRC julia :eval never :exports code
module MyBoxing
using RequiredPackage_1,RequiredPackage_2,...
end 
#+END_SRC

and future "# !" statements are executed after using MyBoxing:
#+BEGIN_SRC julia :eval never :exports code
using MyBoxing
# !statements
#+END_SRC
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function initialize_boxing_module(;
                                  boxingModule::String="BoxingModule",
                                  usedModules::Vector{String}=String[],
                                  force::Bool=false)::Nothing
    # Common errors
    @assert boxingModule!=""
    @assert usedModules!=String[""]
    
    # initialize a module (for boxing)
    module_exists = isdefined(J4Org,Symbol(boxingModule))

    if force||(!module_exists)
        if length(usedModules)>0
            usedModules_asString = "using $(foldr((x,y)->x*", "*y,"",usedModules)[1:end-2]) "
        else
            usedModules_asString = ""
        end
        if VERSION < v"0.7.0-alpha"
            eval(parse("module $(boxingModule) $(usedModules_asString) end"))
        else
            Meta.eval(parse("module $(boxingModule) $(usedModules_asString) end"))
        end
    else
        # force=false && module_exists = true
        # -> nothing is done... interpreted as an error if usedModules if different
        # --> however for the moment we do not know how to get module "used" module_name
        #     thus we trigger an error if usedModules is not empty 
        @assert isempty(usedModules) "Tried to define an already existing module, maybe use the force=true kwarg"
    end
    nothing
end
#+END_SRC
[[file:../src/evaluate.jl::18][evaluate.jl:18]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=is_endmarker=*  <<Igmna4FW>>
#+BEGIN_SRC julia :eval never :exports code
is_endmarker(tok::Tokenized,idx::Int)::Bool
#+END_SRC
#+BEGIN_QUOTE
Checks for ENDMARKER (end of code)
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
is_endmarker(tok::Tokenized,idx::Int)::Bool = (idx<=length(tok)) && (exactkind(tok[idx])==Tokenize.Tokens.ENDMARKER)
#+END_SRC
[[file:../src/tokenizer.jl::19][tokenizer.jl:19]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=is_enum=*  <<cnlfU4gA>>
#+BEGIN_SRC julia :eval never :exports code
function is_enum(tok::Tokenized,idx::Int)::Bool
#+END_SRC
#+BEGIN_QUOTE
Check if tok[i] points on

#+BEGIN_SRC julia :eval never :exports code 
@enum ...
#+END_SRC

#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function is_enum(tok::Tokenized,idx::Int)::Bool
    return (idx+1<=length(tok)) &&
        (exactkind(tok[idx])==Tokenize.Tokens.AT_SIGN) &&
        (untokenize(tok[idx+1])=="enum")
end
#+END_SRC
[[file:../src/tokenizer.jl::45][tokenizer.jl:45]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=is_opening_parenthesis=*  <<B3AHGHUx>>
#+BEGIN_SRC julia :eval never :exports code
is_opening_parenthesis(tok::Tokenized,idx::Int)::Bool
#+END_SRC
#+BEGIN_SRC julia :eval never :exports code
is_opening_parenthesis(tok::Tokenized,idx::Int)::Bool = (idx<=length(tok)) && (kind(tok[idx])==Tokenize.Tokens.LPAREN)
#+END_SRC
[[file:../src/tokenizer.jl::61][tokenizer.jl:61]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=is_structure=*  <<ovJKVcOA>>
#+BEGIN_SRC julia :eval never :exports code
is_structure(tok::Tokenized,idx::Int)::Bool
#+END_SRC
#+BEGIN_SRC julia :eval never :exports code
is_structure(tok::Tokenized,idx::Int)::Bool = (idx<=length(tok)) && (exactkind(tok[idx])==Tokenize.Tokens.STRUCT)
#+END_SRC
[[file:../src/tokenizer.jl::11][tokenizer.jl:11]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=is_whitespace_n=*  <<MrpF1KWz>>
#+BEGIN_SRC julia :eval never :exports code
is_whitespace_n(tok::Tokenized,idx::Int)::Bool
#+END_SRC
#+BEGIN_QUOTE
Checks for "\n"
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
is_whitespace_n(tok::Tokenized,idx::Int)::Bool = is_whitespace(tok,idx) && (untokenize(tok[idx])=="\n")
#+END_SRC
[[file:../src/tokenizer.jl::16][tokenizer.jl:16]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=org_string_code=*  <<LtzKMe0E>>
#+BEGIN_SRC julia :eval never :exports code
function org_string_code(di::Documented_Item)::String
#+END_SRC
#+BEGIN_QUOTE
Print first line of code

For instance:
#+BEGIN_SRC julia :eval never
function foo()
#+END_SRC
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function org_string_code(di::Documented_Item)::String
    s=raw_string_code(di)
    if !isempty(s)
        s="#+BEGIN_SRC julia :eval never :exports code\n$(s)\n#+END_SRC\n"
    end
    return s
end
#+END_SRC
[[file:../src/org_string_code.jl::1][org_string_code.jl:1]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=org_string_code_with_body=*  <<UCIW5kc5>>
#+BEGIN_SRC julia :eval never :exports code
function org_string_code_with_body(di::Documented_Item)::String
#+END_SRC
#+BEGIN_QUOTE
Print first line of code AND body

For instance:
#+BEGIN_SRC julia :eval never
function foo()
  # foo body
end
#+END_SRC
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function org_string_code_with_body(di::Documented_Item)::String
    s=raw_string_code_with_body(di)
    if !isempty(s)
        s="#+BEGIN_SRC julia :eval never :exports code\n$(s)\n#+END_SRC\n"
    end
    return s
end
#+END_SRC
[[file:../src/org_string_code.jl::18][org_string_code.jl:18]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=print_org_doc=*  <<6NnAKWM4>> <<API_print_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule",
                       with_body::Bool=false)
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_SRC julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(documented_items,tag="API",header_level=0)
,#+END_SRC
#+END_SRC

*Arguments:*
- =tag=: tags to collect when generating the documentation
- =tag_to_ignore=: tags to ignore when generating the documentation
- =identifier=: generates documentation for this "identifier". Can be a function name, a structure name, etc…
- =link_prefix=: allows to add a prefix to extra link (#+tag L=extra_link). this is can be useful to avoid link name conflict when performing local doc extraction.
- =complete_link=: if true, try to fix link without target by adding extra items
- =case_sensitive=: case sensitive index.
- =boxingModule=: specifies the context in which "#!" code will be executed. See [[API_initialize_boxing_module][initialize_boxing_module(...)]] for details.
- =with_body::Bool=: if true include code body
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule",
                       with_body::Bool=false)
    print(org_string_documented_item_array(di_array,
                                           tag=tag,
                                           tag_to_ignore=tag_to_ignore,
                                           identifier=identifier,
                                           header_level=header_level,
                                           link_prefix=link_prefix,
                                           complete_link=complete_link,
                                           case_sensitive=case_sensitive,
                                           boxingModule=boxingModule,
                                           with_body=with_body))
end
#+END_SRC
[[file:../src/main.jl::359][main.jl:359]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=raw_string_with_body=*  <<HsvMoBaE>>
#+BEGIN_SRC julia :eval never :exports code
raw_string_with_body(ex::Extracted_Function)::String
#+END_SRC
#+BEGIN_SRC julia :eval never :exports code
raw_string_with_body(ex::Extracted_Function)::String = untokenize(ex._tok[ex._idx_array_with_body])


#+END_SRC
[[file:../src/extract.jl::92][extract.jl:92]], [[kgn9knpD][back to index]]

#+BEGIN_SRC julia :eval never :exports code
raw_string_with_body(ex::Extracted_Struct)::String
#+END_SRC
#+BEGIN_SRC julia :eval never :exports code
raw_string_with_body(ex::Extracted_Struct)::String = untokenize(ex._tok[ex._idx_array_with_body])


#+END_SRC
[[file:../src/extract.jl::155][extract.jl:155]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_abstract_block=*  <<tCR0D5WJ>>
#+BEGIN_SRC julia :eval never :exports code
function skip_abstract_block(tok::Tokenized,idx::Int;
                             identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & abstract type block
Does not move is identifier not found

#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_abstract_block(tok::Tokenized,idx::Int;
                             identifier::Ref{String}=Ref{String}(""))::Int
    identifier[]=""
    idx_save = idx
    idx = skip_uninformative(tok,idx)

    if is_abstract(tok,idx)

        idx = idx+1
        idx = skip_uninformative(tok,idx)

        if is_type(tok,idx)
            idx = idx + 1
            idx_check_success = idx
            idx = skip_identifier(tok,idx,identifier=identifier)

            if idx_check_success != idx
                # no need to check success as subtype is not mandatory
                idx = idx + 1
                idx = skip_issubtype_block(tok,idx)

                # success
                return idx
            end
        end
    end
    
    return idx_save
end
#+END_SRC
[[file:../src/tokenizer.jl::415][tokenizer.jl:415]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_comma_separated_identifiers=*  <<PX7r6tvj>>
#+BEGIN_SRC julia :eval never :exports code
function skip_comma_separated_identifiers(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a comma separated sequence of identifiers A,A.B.C,A.B{...}
Does not move is comma separeted identifier not found
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_comma_separated_identifiers(tok::Tokenized,idx::Int)::Int
    idx_save = idx
    idx = skip_uninformative(tok,idx)
    if !is_identifier(tok,idx)
        return idx_save
    end

    n=length(tok)
    while idx<=n
        idx=skip_identifier(tok,idx)
        idx_save=idx
        idx=skip_uninformative(tok,idx)
        if !is_comma(tok,idx)
            return idx_save
        end
        idx=idx+1
        idx=skip_uninformative(tok,idx)
        if !is_identifier(tok,idx)
            return idx_save
        end
    end
#+END_SRC
[[file:../src/tokenizer.jl::261][tokenizer.jl:261]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_comment=*  <<YI07DWf2>>
#+BEGIN_SRC julia :eval never :exports code
function skip_comment(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip comment
-> replaced by skip uninformative
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_comment(tok::Tokenized,idx::Int)
    while (idx<=length(tok))&&(is_comment(tok,idx)||is_whitespace(tok,idx))
        idx=idx+1
    end
#+END_SRC
[[file:../src/tokenizer.jl::82][tokenizer.jl:82]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_declaration_block=*  <<tOSOPVhb>>
#+BEGIN_SRC julia :eval never :exports code
function skip_declaration_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a declaration block ::identifier{...}
Does not move in case of identification failure
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_declaration_block(tok::Tokenized,idx::Int)::Int
    idx_save = idx
    idx = skip_uninformative(tok,idx)
    if !is_declaration(tok,idx)
        return idx_save
    end

    idx=idx+1
    idx=skip_uninformative(tok,idx)

    if is_identifier(tok,idx)
        return skip_identifier(tok,idx)
    end

    return idx_save
end
#+END_SRC
[[file:../src/tokenizer.jl::312][tokenizer.jl:312]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_enum_block=*  <<20w33ocb>>
#+BEGIN_SRC julia :eval never :exports code
function skip_enum_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & @enum ... line
Does not move is identifier not found

#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_enum_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
    identifier[]=""
    idx_save = idx
    idx = skip_uninformative(tok,idx)

    if is_enum(tok,idx)

        idx = idx+2 # caveat skip @ AND enum 
        idx_check_success = idx
        idx = skip_identifier(tok,idx,identifier=identifier)

        if idx_check_success != idx
            # move until end of line (ignoring comment if any)
            idx = skip_line(tok,idx)
            return idx
        end
    end
    
    return idx_save
end
#+END_SRC
[[file:../src/tokenizer.jl::459][tokenizer.jl:459]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_function_call_block=*  <<mSsOaF7i>>
#+BEGIN_SRC julia :eval never :exports code
function skip_function_call_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a function call block identifier{...}(....)
Does not move in case of identification failure
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_function_call_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
    identifier[]=""
    idx_save = idx
    idx = skip_uninformative(tok,idx)
    if !is_identifier(tok,idx)
        return idx_save
    end

    idx=skip_identifier(tok,idx,identifier=identifier)
    idx=skip_uninformative(tok,idx)

    if is_opening_parenthesis(tok,idx)
        idx=find_closing_parenthesis(tok,idx)
        idx=idx+1
        return idx
    end

    return idx_save
end
#+END_SRC
[[file:../src/tokenizer.jl::331][tokenizer.jl:331]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_identifier=*  <<SaViG9fx>>
#+BEGIN_SRC julia :eval never :exports code
function skip_identifier(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & identifier A or A.B.C or A.B{...}
Returns (name,idx) if prod
Does not move is identifier not found

#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_identifier(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
    identifier[]=""
    idx_save = idx
    idx = skip_uninformative(tok,idx)
    if !is_identifier(tok,idx)
        return idx_save
    end

    n=length(tok)
    identifier[] = untokenize(tok[idx])
    while idx<=n
        idx=idx+1
        idx_save = idx
        idx=skip_whitespace_strict(tok,idx)
        if is_dot(tok,idx)
            idx=idx+1
            idx=skip_whitespace_strict(tok,idx)
            if is_identifier(tok,idx)
                identifier[]=identifier[]*"."*untokenize(tok[idx])
                continue
            else
                identifier[]=""
                return idx_save # failure
            end
        end 
        
        if is_opening_brace(tok,idx)
            idx=find_closing_brace(tok,idx)
            return idx+1
        end

        return idx_save
    end
#+END_SRC
[[file:../src/tokenizer.jl::213][tokenizer.jl:213]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_issubtype_block=*  <<Fgozo6uY>>
#+BEGIN_SRC julia :eval never :exports code
function skip_issubtype_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & issubtype indentifier
Does not move is identifier not found

#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_issubtype_block(tok::Tokenized,idx::Int)::Int
    idx_save = idx
    idx = skip_uninformative(tok,idx)

    if !is_issubtype(tok,idx)
        return idx_save
    end
    idx=idx+1
    idx_check_success = idx
    idx = skip_identifier(tok,idx)

    if idx != idx_check_success
        return idx
    end

    return idx_save
end
#+END_SRC
[[file:../src/tokenizer.jl::357][tokenizer.jl:357]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_line=*  <<QpWx2mHu>>
#+BEGIN_SRC julia :eval never :exports code
function skip_line(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Moves idx until it reaches a comment #, end of line \n or of file ENDMARKER

#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_line(tok::Tokenized,idx::Int)::Int
    while !(is_comment(tok,idx)||is_endmarker(tok,idx)||is_whitespace_n(tok,idx))
        idx=idx+1
    end
#+END_SRC
[[file:../src/tokenizer.jl::449][tokenizer.jl:449]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_macro_block=*  <<yuPCfAhE>>
#+BEGIN_SRC julia :eval never :exports code
function skip_macro_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & @enum ... line
Does not move is identifier not found

#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_macro_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
    identifier[]=""
    idx_save = idx
    idx = skip_uninformative(tok,idx)

    
    if is_macro(tok,idx)
        idx=idx+1    
        idx_check_success = idx
        idx = skip_identifier(tok,idx,identifier=identifier)

        if idx_check_success != idx
            idx=skip_uninformative(tok,idx)

            if is_opening_parenthesis(tok,idx)
                idx=find_closing_parenthesis(tok,idx)
                idx=idx+1
                return idx
            end
        end
    end 
    return idx_save
end
#+END_SRC
[[file:../src/tokenizer.jl::514][tokenizer.jl:514]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_struct_block=*  <<37LOskpd>>
#+BEGIN_SRC julia :eval never :exports code
function skip_struct_block(tok::Tokenized,idx::Int;
                          identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & structure block
Does not move is identifier not found

#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_struct_block(tok::Tokenized,idx::Int;
                          identifier::Ref{String}=Ref{String}(""))::Int
    identifier[]=""
    idx_save = idx
    idx = skip_uninformative(tok,idx)

    check_is_structure = is_structure(tok,idx)
    check_is_mutable = is_mutable(tok,idx)
    
    if !(check_is_structure||check_is_mutable)
        return idx_save
    end

    if check_is_mutable
        idx=idx+1
        idx = skip_uninformative(tok,idx)

        if !is_structure(tok,idx)
            return idx_save
        end
    end

    @assert is_structure(tok,idx)
    
    idx=idx+1
    idx = skip_identifier(tok,idx,identifier=identifier)
    idx = skip_issubtype_block(tok,idx)
    
    return idx
end
#+END_SRC
[[file:../src/tokenizer.jl::379][tokenizer.jl:379]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_uninformative=*  <<bSaTXGqn>>
#+BEGIN_SRC julia :eval never :exports code
function skip_uninformative(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip whitespace 
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_uninformative(tok::Tokenized,idx::Int)
    while (idx<=length(tok))&&(is_comment(tok,idx)||is_whitespace(tok,idx))
        idx=idx+1
    end
#+END_SRC
[[file:../src/tokenizer.jl::92][tokenizer.jl:92]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_variable_block=*  <<FTJIISZE>>
#+BEGIN_SRC julia :eval never :exports code
function skip_variable_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uniformative & const A
Does not move is identifier not found

#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_variable_block(tok::Tokenized,idx::Int;
                         identifier::Ref{String}=Ref{String}(""))::Int
    identifier[]=""
    idx_save = idx
    idx = skip_uninformative(tok,idx)

    
    if is_const(tok,idx)
        idx =  skip_uninformative(tok,idx+1)
    end

    if is_global(tok,idx)||is_local(tok,idx)
        idx =  skip_uninformative(tok,idx+1)
    end
    
    idx_check_success = idx
    idx = skip_identifier(tok,idx,identifier=identifier)

    if idx_check_success != idx
        return idx
    end
    
    return idx_save
end
#+END_SRC
[[file:../src/tokenizer.jl::485][tokenizer.jl:485]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_where_block=*  <<vQ8mjYCX>>
#+BEGIN_SRC julia :eval never :exports code
function skip_where_block(tok::Tokenized,idx::Int)::Int
#+END_SRC
#+BEGIN_QUOTE
Skips uninformative & a where block (where {...} or where A,B
Does not move is comma separeted identifier not found
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_where_block(tok::Tokenized,idx::Int)::Int
    idx_save = idx
    idx = skip_uninformative(tok,idx)
    if !is_where(tok,idx)
        return idx_save
    end

    idx=idx+1
    idx = skip_uninformative(tok,idx)

    if is_opening_brace(tok,idx)
        return find_closing_brace(tok,idx)+1
    end

    if is_identifier(tok,idx)
        return skip_comma_separated_identifiers(tok,idx)
    end

    return idx_save
end
#+END_SRC
[[file:../src/tokenizer.jl::288][tokenizer.jl:288]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_whitespace=*  <<AGMSIZGx>>
#+BEGIN_SRC julia :eval never :exports code
function skip_whitespace(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip comment + whitespace 
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_whitespace(tok::Tokenized,idx::Int)
    while (idx<=length(tok))&&is_whitespace(tok,idx)
        idx=idx+1
    end
#+END_SRC
[[file:../src/tokenizer.jl::101][tokenizer.jl:101]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=skip_whitespace_strict=*  <<7P1f9wMv>>
#+BEGIN_SRC julia :eval never :exports code
function skip_whitespace_strict(tok::Tokenized,idx::Int)
#+END_SRC
#+BEGIN_QUOTE
Skip whitespace
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
function skip_whitespace_strict(tok::Tokenized,idx::Int)
    while (idx<=length(tok))&&(is_whitespace_strict(tok,idx))
        idx=idx+1
    end
#+END_SRC
[[file:../src/tokenizer.jl::127][tokenizer.jl:127]], [[kgn9knpD][back to index]]
- @@latex:\phantomsection@@ *=tokenized=*  <<tmrp9U7X>>
#+BEGIN_SRC julia :eval never :exports code
tokenized(s::String)
#+END_SRC
#+BEGIN_QUOTE
Defines a convenient method to tokenize a =String=
#+END_QUOTE
#+BEGIN_SRC julia :eval never :exports code
tokenized(s::String) = collect(tokenize(s))



#+END_SRC
[[file:../src/tokenizer.jl::6][tokenizer.jl:6]], [[kgn9knpD][back to index]]
:END:


* More examples and Tips                                           :noexport:

*** Org-mode block in comment

For the moment these blocks are left unchanged. For the moment only EXAMPLE blocks work. For instance:
# CAVEAT: can not use RESULT because of NESTED EXAMPLE BLOCKS (org is lost!)
#+BEGIN_EXAMPLE
# Prints doc. This is the main function of the =J4Org= package.
#
# *Org-Mode Usage example:*
# #+BEGIN_EXAMPLE
# ,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
# documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
# print_org_doc(tag="API",header_level=0)
# ,#+END_SRC
# #+END_EXAMPLE
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::String="",
                       identifier::String="",
                       header_level::Int=0) = ...
#+END_EXAMPLE





This will generate this doc: 
#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("../src/");
print_org_doc(documented_items,identifier="print_org_doc",header_level=-1)
#+END_SRC

#+RESULTS:
:RESULTS:

 @@latex:\phantomsection@@  <<symMTtnLprint_org_doc_API>>
#+BEGIN_SRC julia :eval never :exports code
function print_org_doc(di_array::Array{Documented_Item,1};
                       tag::Union{String,Array{String,1}}="",
                       tag_to_ignore::Union{String,Array{String,1}}="",
                       identifier::String="",
                       header_level::Int=0,
                       link_prefix::String=randstring(),
                       complete_link::Bool=false,
                       case_sensitive::Bool=true,
                       boxingModule::String="BoxingModule")
#+END_SRC
#+BEGIN_QUOTE
Prints generated documentation to be exported by OrgMode, this is the main function of the =J4Org= package.

*Org-Mode Usage example:*
#+BEGIN_SRC julia :eval never :exports code
,#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items = create_documented_item_array_dir("~/GitLab/MyPackage.jl/src/");
print_org_doc(documented_items,tag="API",header_level=0)
,#+END_SRC
#+END_SRC

*Arguments:*
- =tag=: tags to collect when generating the documentation
- =tag_to_ignore=: tags to ignore when generating the documentation
- =identifier=: generates documentation for this "identifier". Can be a function name, a structure name, etc…
- =link_prefix=: allows to add a prefix to extra link (#+tag L=extra_link). this is can be useful to avoid link name conflict when performing local doc extraction.
- =complete_link=: if true, try to fix link without target by adding extra items
- =case_sensitive=: case sensitive index.
- =boxingModule=: specifies the context in which "#!" code will be executed. See _initialize_boxing_module(...)_ for details.
#+END_QUOTE
[[file:../src/main.jl::350][main.jl:350]]
:END:

*** Julia code block in comment 
    :PROPERTIES:
    :ID:       f896399f-bd8f-4d68-b4ae-f67ed6a313ef
    :END:

You can define Julia code in comment:

#+BEGIN_SRC julia
,#+foo_doc
#
# You can redefine the foo function:
#
# #+BEGIN_SRC julia
# # julia code example
# foo(x::Float64) = 1
# #+END_SRC
#
foo(x::Int) = 2*x
#+END_SRC

#+RESULTS:

The generated code is:

#+RESULTS:
:RESULTS:


#+BEGIN_SRC julia
foo(x::Int)
#+END_SRC

#+RESULTS:

#+BEGIN_QUOTE
You can redefine the foo function:

#+BEGIN_SRC julia
# julia code example
foo(x::Float64) = 1
#+END_SRC

#+RESULTS:

#+END_QUOTE
[[file:./code_examples/meaninglesscode.jl::1][meaninglesscode.jl:1]]
:END:

*Note:* maybe in the future Julia SRC blocks will be evaluated,
 however this functionality is not available for the moment.

*** Obsolete stuff

You can use 
#+BEGIN_EXAMPLE
- [ ] todo 
#+END_EXAMPLE
in a comment block 

for instance
#+BEGIN_EXAMPLE
,#+Obsolete
#
#  - [ ] remove me (to be replaced by find_tag)
#
function is_tag(tok::Tokenized,idx::Int)::Bool
#+END_EXAMPLE




* Unit tests

#+BEGIN_SRC julia :results output table :exports results
include("../test/runtests.jl")
#+END_SRC

#+RESULTS:
: Test Summary: | Pass  Total
: J4Org         |  126    126

* Code/Design tips                                                
** PDF export & phantomsection 

To be able to use links everywhere we use the
="@@latex:\\phantomsection@@"= tricks. See
[[https://tex.stackexchange.com/questions/44088/when-do-i-need-to-invoke-phantomsection][when-do-i-need-to-invoke-phantomsection]] for instance.

** HTML export with background

See https://github.com/JuliaEditorSupport/julia-emacs/issues/53

** Steps to add a new item 
We use =enum= as example
*** =tokenizer.jl= file
Add: =is_enum()= and =skip_enum_block()= functions
**** tests 
Add 
#+BEGIN_SRC julia :eval never :exports code 
import J4Org: is_enum

@testset "is_enum" begin
    t=tokenized("@enum Alpha A B")
    @test is_enum(t,1)
end;

#+END_SRC
*** =extract.jl= file
Add: =struct Extracted_Enum= and =extract_enum()= function.

Then complete =extract_code()= to take into account the extracted =Documented_Item=.
**** tests 
Create a basic file like: =test/code_example/enum.jl=
#+BEGIN_SRC 
,#+Tag L:target 
# This is an enum example [[target][]]
@enum Alpha A  B=1 C
#+END_SRC
Add 
#+BEGIN_SRC julia
import J4Org: extract_enum

@testset "enum" begin
    filename="$(dirname(@__FILE__))/code_examples/enum.jl"
    t=tokenized(readstring(filename))
    r = extract_enum(t,1)
    @test r!=nothing
    @test raw_string(r) == "@enum Alpha A  B=1 C"
    @test identifier(r) == "Alpha"
end;
#+END_SRC
*** =link.jl= file 

This is not mandatory, however if you want to magnify link to enum,
you can update the =create_link_readable_part()= function.
**** tests 
Link magnification is checked in [[id:b84e7269-ae02-4c64-b180-6b50d6f8aa89][=documented_item.jl=]]
*** =documented_item.jl=
    :PROPERTIES:
    :ID:       b84e7269-ae02-4c64-b180-6b50d6f8aa89
    :END:
Add the =is_documented_enum_type()= function.
**** tests 
Add 
#+BEGIN_SRC julia :eval never :exports code 
@testset "enum" begin
    filename="$(dirname(@__FILE__))/code_examples/enum.jl"
    t=tokenized(readstring(filename))
    r=find_tag(t,1)
    di=create_documented_item(t,tag_idx(r),filename=filename)
    @test org_string_comment(di,[di],[di],"","BoxingModule") == 
      "#+BEGIN_QUOTE\nThis is an enum example [[target][@enum Alpha]]\n#+END_QUOTE\n"
    @test org_string_code(di) == 
     "#+BEGIN_SRC julia :eval never :exports code\n@enum Alpha A  B=1 C\n#+END_SRC\n"
 end;
#+END_SRC

